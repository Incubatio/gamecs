// Generated by CoffeeScript 1.4.0
(function() {

  define(function(require) {
    var Group, Sprite;
    Sprite = require('sprite');
    /**
    * Sprites are often grouped. That makes collision detection more efficient and
    * improves rendering performance. It also allows you to easly keep track of layers
    * of objects which are rendered to the screen in a particular order.
    *
    * `Group.update()` calls `update()` on all the contained sprites the same is true for `draw()`.
    * @constructor
    */

    return Group = (function() {

      function Group() {
        /** @ignore
        */
        this._sprites = [];
        if (arguments[0] instanceof Sprite || (arguments[0] instanceof Array && arguments[0].length && arguments[0][0] instanceof Sprite)) {
          this.add(arguments[0]);
        }
      }

      /**
      * Update all the sprites in this group. This is equivalent to calling the
      * update method on each sprite in this group.
      */


      Group.prototype.update = function() {
        var updateArgs;
        updateArgs = arguments;
        return this._sprites.forEach(function(sp) {
          return sp.update.apply(sp, updateArgs);
        }, this);
      };

      /**
      * Add one or more sprites to this group
      * @param {Array|gamecs.sprite.Sprite} sprites One or more
      * `gamecs.sprite.Sprite` instances
      */


      Group.prototype.add = function(sprites) {
        if (!(sprites instanceof Array)) {
          sprites = [sprites];
        }
        return sprites.forEach(function(sprite) {
          this._sprites.push(sprite);
          return sprite._groups.push(this);
        }, this);
      };

      /**
      * Remove one or more sprites from this group
      * @param {Array|gamecs.sprite.Sprite} sprites One or more
      * `gamecs.sprite.Sprite` instances
      */


      Group.prototype.remove = function(sprites) {
        if (!(sprites instanceof Array)) {
          sprites = [sprites];
        }
        sprites.forEach(function(sp) {
          Arrays.remove(sp, this._sprites);
          return Arrays.remove(this, sp._groups);
        }, this);
      };

      /**
      * Check for the existence of one or more sprites within a group
      * @param {Array|gamecs.sprite.Sprite} sprites One or more
      * `gamecs.sprite.Sprite` instances
      * @returns {Boolean} True if every sprite is in this group, false otherwise
      */


      Group.prototype.has = function(sprites) {
        if (!(sprites instanceof Array)) {
          sprites = [sprites];
        }
        return sprites.every(function(sp) {
          return this._sprites.indexOf(sp) !== -1;
        }, this);
      };

      /**
      * Get the sprites in this group
      * @returns {Array} An array of `gamecs.sprite.Sprite` instances
      */


      Group.prototype.sprites = function() {
        return this._sprites;
      };

      /*
          * Draw all the sprites in this group. This is equivalent to calling each
          * sprite's draw method.
      */


      Group.prototype.draw = function() {
        var args;
        args = arguments;
        this._sprites.forEach(function(sprite) {
          return sprite.draw.apply(sprite, args);
        }, this);
      };

      /**
      * Draw background (`source` argument) over each sprite in the group
      * on the `destination` surface.
      *
      * This can, for example, be used to clear the
      * display surface to a a static background image in all the places
      * occupied by the sprites of all group.
      *
      * @param {gamecs.Surface} destination the surface to draw on
      * @param {gamecs.Surface} source surface
      */


      Group.prototype.clear = function(destination, source) {
        return this._sprites.forEach(function(sprite) {
          return destination.blit(source, sprite.rect);
        }, this);
      };

      /**
      * Remove all sprites from this group
      */


      Group.prototype.empty = function() {
        this._sprites = [];
      };

      /**
      * @returns {Array} of sprites colliding with the point
      */


      Group.prototype.collidePoint = function() {
        var args;
        args = Array.prototype.slice.apply(arguments);
        return this._sprites.filter(function(sprite) {
          return sprite.rect.collidePoint.apply(sprite.rect, args);
        }, this);
      };

      /**
      * Loop over each sprite in this group. This is a shortcut for
      * `group.sprites().forEach(...)`.
      */


      Group.prototype.forEach = function(callback, thisArg) {
        return this._sprites.forEach(callback, thisArg);
      };

      /**
      * Check whether some sprite in this group passes a test. This is a shortcut
      * for `group.sprites().some(...)`.
      */


      Group.prototype.some = function(callback, thisArg) {
        return this._sprites.some(callback, thisArg);
      };

      /**
      * Find sprites in a group that intersect another sprite
      * @param {gamecs.sprite.Sprite} sprite The sprite to check
      * @param {gamecs.sprite.Group} group The group to check
      * @param {Boolean} doKill If true, kill sprites in the group when collided
      * @param {function} collided Collision function to use, defaults to `gamecs.sprite.collideRect`
      * @returns {Array} An array of `gamecs.sprite.Sprite` instances that collided
      */


      Group.spriteCollide = function(sprite, group, doKill, collided) {
        var collidingSprites;
        collided = collided || collideRect;
        doKill = doKill || false;
        collidingSprites = [];
        group.sprites().forEach(function(groupSprite) {
          if (collided(sprite, groupSprite)) {
            if (doKill) {
              groupSprite.kill();
            }
            return collidingSprites.push(groupSprite);
          }
        });
        return collidingSprites;
      };

      /**
      * Find all Sprites that collide between two Groups.
      *
      * @example
      * groupCollide(group1, group2).forEach(function (collision) {
      *    group1Sprite = collision.a
      *    group2Sprite = collision.b
      *    // Do processing here!
      * })
      *
      * @param {gamecs.sprite.Group} groupA First group to check
      * @param {gamecs.sprite.Group} groupB Second group to check
      * @param {Boolean} doKillA If true, kill sprites in the first group when
      * collided
      * @param {Boolean} doKillB If true, kill sprites in the second group when
      * collided
      * @param {function} collided Collision function to use, defaults to `gamecs.sprite.collideRect`
      * @returns {Array} A list of objects where properties 'a' and 'b' that
      * correspond with objects from the first and second groups
      */


      Group.groupCollide = function(groupA, groupB, doKillA, doKillB, collided) {
        var collideFn, collideList;
        doKillA = doKillA || false;
        doKillB = doKillB || false;
        collideList = [];
        collideFn = collided || collideRect;
        groupA.sprites().forEach(function(groupSpriteA) {
          return groupB.sprites().forEach(function(groupSpriteB) {
            if (collideFn(groupSpriteA, groupSpriteB)) {
              if (doKillA) {
                groupSpriteA.kill();
              }
              if (doKillB) {
                groupSpriteB.kill();
              }
              return collideList.push({
                a: groupSpriteA,
                b: groupSpriteB
              });
            }
          });
        });
        return collideList;
      };

      /**
      * Check for collisions between two sprites using their rects.
      *
      * @param {gamecs.sprite.Sprite} spriteA First sprite to check
      * @param {gamecs.sprite.Sprite} spriteB Second sprite to check
      * @returns {Boolean} True if they collide, false otherwise
      */


      Group.collideRect = function(spriteA, spriteB) {
        return spriteA.rect.collideRect(spriteB.rect);
      };

      /**
      * Collision detection between two sprites utilizing the optional `mask`
      * attribute on the sprites. Beware: expensive operation.
      *
      * @param {gamecs.sprite.Sprite} spriteA Sprite with 'mask' property set to a `gamecs.mask.Mask`
      * @param {gamecs.sprite.Sprite} spriteB Sprite with 'mask' property set to a `gamecs.mask.Mask`
      * @returns {Boolean} True if any mask pixels collide, false otherwise
      */


      Group.collideMask = function(spriteA, spriteB) {
        var offset;
        if (!spriteA.mask || !spriteB.mask) {
          throw new Error("Both sprites must have 'mask' attribute set to an gamecs.mask.Mask");
        }
        offset = [spriteB.rect.left - spriteA.rect.left, spriteB.rect.top - spriteA.rect.top];
        return spriteA.mask.overlap(spriteB.mask, offset);
      };

      /**
      * Collision detection between two sprites using circles at centers.
      * There sprite property `radius` is used if present, otherwise derived from bounding rect.
      * @param {gamecs.sprite.Sprite} spriteA First sprite to check
      * @param {gamecs.sprite.Sprite} spriteB Second sprite to check
      * @returns {Boolean} True if they collide, false otherwise
      */


      Group.collideCircle = function(spriteA, spriteB) {
        var rA, rB;
        rA = spriteA.radius || Math.max(spriteA.rect.width, spriteA.rect.height);
        rB = spriteB.radius || Math.max(spriteB.rect.width, spriteB.rect.height);
        return Vector.distance(spriteA.rect.center, spriteB.rect.center) <= rA + rB;
      };

      return Group;

    })();
  });

}).call(this);
