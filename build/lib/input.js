// Generated by CoffeeScript 1.4.0
(function() {

  define(function(require) {
    /**
    * @fileoverview Methods for polling mouse and keyboard.
    *
    * Call `gamecs.Input.get()` in your main loop to get a list of input events that happend
    * since your last call.
    *
    * Note that some events, which would trigger a default browser action, are prevented
    * from triggering their default behaviour if and only if the game's display canvas has
    * focus (the game gets focus if the user clicked on the game).
    *
    * All events have a type identifier. This event type is in between the values
    * of NOEVENT and NUMEVENTS. Each event has a constant in `gamecs.event.*` 
    * All user defined events can have the value of USEREVENT or higher.
    * Make sure your custom event ids* follow this system.
    * 
    * A pattern for using the event loop: your main game function (tick in this example)
    * is being called by [gamecs.time.interval()](../time/#interval).
    * Inside tick we call [gamecs.Input.get()](#get) for a list of events that happened since the last
    * tick and we loop over each event and act on the event properties.
    *
    * @example
    *     events = gamecs.Input.get()
    *     events.forEach(function(event) {
    *        if (event.type == gamecs.Input.T_MOUSE_UP) {
    *          gamecs.log(event.pos, event.button)
    *        } else if (event.type == gamecs.Input.T_KEY_UP) {
    *          gamecs.log(event.key)
    *        }
    *     })
    *
    */

    var Input, lastPos;
    lastPos = [];
    return Input = (function() {
      var _getCanvasOffset, _getContainer, _hasFocus;

      function Input() {}

      /* key constants
      */


      Input.K_LEFT = 37;

      Input.K_UP = 38;

      Input.K_RIGHT = 39;

      Input.K_DOWN = 40;

      Input.K_BACKSPACE = 8;

      Input.K_TAB = 9;

      Input.K_ENTER = 13;

      Input.K_SHIFT = 16;

      Input.K_CTRL = 17;

      Input.K_ALT = 18;

      Input.K_ESC = 27;

      Input.K_SPACE = 32;

      Input.K_0 = 48;

      Input.K_1 = 49;

      Input.K_2 = 50;

      Input.K_3 = 51;

      Input.K_4 = 52;

      Input.K_5 = 53;

      Input.K_6 = 54;

      Input.K_7 = 55;

      Input.K_8 = 56;

      Input.K_9 = 57;

      Input.K_a = 65;

      Input.K_b = 66;

      Input.K_c = 67;

      Input.K_d = 68;

      Input.K_e = 69;

      Input.K_f = 70;

      Input.K_g = 71;

      Input.K_h = 72;

      Input.K_i = 73;

      Input.K_j = 74;

      Input.K_k = 75;

      Input.K_l = 76;

      Input.K_m = 77;

      Input.K_n = 78;

      Input.K_o = 79;

      Input.K_p = 80;

      Input.K_q = 81;

      Input.K_r = 82;

      Input.K_s = 83;

      Input.K_t = 84;

      Input.K_u = 85;

      Input.K_v = 86;

      Input.K_w = 87;

      Input.K_x = 88;

      Input.K_y = 89;

      Input.K_z = 90;

      Input.K_KP1 = 97;

      Input.K_KP2 = 98;

      Input.K_KP3 = 99;

      Input.K_KP4 = 100;

      Input.K_KP5 = 101;

      Input.K_KP6 = 102;

      Input.K_KP7 = 103;

      Input.K_KP8 = 104;

      Input.K_KP9 = 105;

      /* event type constants
      */


      Input.NOEVENT = 0;

      Input.NUMEVENTS = 32000;

      Input.T_QUIT = 0;

      Input.T_KEY_DOWN = 1;

      Input.T_KEY_UP = 2;

      Input.T_MOUSE_MOTION = 3;

      Input.T_MOUSE_UP = 4;

      Input.T_MOUSE_DOWN = 5;

      Input.T_MOUSE_WHEEL = 6;

      Input.T_USEREVENT = 2000;

      Input.QUEUE = [];

      /**
      * Get all events from the event queue
      * @returns {Array}
      */


      Input.get = function(eventTypes) {
        var result;
        if (eventTypes === void 0) {
          return Input.QUEUE.splice(0, Input.QUEUE.length);
        } else {
          if (!(eventTypes instanceof Array)) {
            eventTypes = [eventTypes];
          }
          result = [];
          Input.QUEUE = Input.QUEUE.filter(function(event) {
            if (eventTypes.indexOf(event.type) === -1) {
              return true;
            }
            result.push(event);
            return false;
          });
          return result;
        }
      };

      /**
      * Get the newest event of the event queue
      * @returns {gamecs.event.Event}
      */


      Input.poll = function() {
        return Input.QUEUE.pop();
      };

      /**
      * Post an event to the event queue.
      * @param {gamecs.event.Event} userEvent the event to post to the queue
      */


      Input.post = function(userEvent) {
        return Input.QUEUE.push(userEvent);
      };

      /**
      * Remove all events from the queue
      */


      Input.clear = function() {
        return Input.QUEUE = [];
      };

      /**
      * Holds all information about an event.
      * @class
      */


      Input.Event = function() {
        /* The type of the event. e.g., gamecs.event.T_QUIT, T_KEY_DOWN, T_MOUSE_UP.
        */
        this.type = null;
        /* key the keyCode of the key. compare with gamecs.event.K_a, gamecs.event.K_b,...
        */

        this.key = null;
        /* relative movement for a mousemove event
        */

        this.rel = null;
        /* the number of the mousebutton pressed
        */

        this.button = null;
        /* pos the position of the event for mouse events
        */

        return this.pos = null;
      };

      /**
      * @ignore
      */


      Input.init = function() {
        lastPos = [];
        /**
        * IEFIX does not support addEventListener on document itself
        * MOZFIX but in moz & opera events don't reach body if mouse outside window or on menubar
        */

        document.addEventListener('mousedown', this.onMouseDown, false);
        document.addEventListener('mouseup', this.onMouseUp, false);
        document.addEventListener('keydown', this.onInputDown, false);
        return document.addEventListener('keyup', this.onInputUp, false);
      };

      Input.initCanvasEvents = function(canvas) {
        canvas.addEventListener('mousemove', this.onMouseMove, false);
        canvas.addEventListener('mousewheel', this.onMouseScroll, false);
        /** 
        * MOZFIX
        * https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events
        */

        canvas.addEventListener('DOMMouseScroll', this.onMouseScroll, false);
        return canvas.addEventListener('beforeunload', this.onBeforeUnload, false);
        /* anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener
        */

      };

      _getContainer = function() {
        return document.getElementById('gcs-container');
      };

      /**
      * The Display (the canvas element) is most likely not in the top left corner
      * of the browser due to CSS styling. To calculate the mouseposition within the
      * canvas we need this offset.
      * @see {gamecs.Input}
      * @ignore
      *
      * @returns {Array} [x, y] offset of the canvas
      */


      _getCanvasOffset = function() {
        var boundRect;
        boundRect = _getContainer().getBoundingClientRect();
        return [boundRect.left, boundRect.top];
      };

      /** @ignore
      */


      _hasFocus = function() {
        return document.activeElement === _getContainer();
      };

      Input.onMouseDown = function(ev) {
        var canvasOffset;
        canvasOffset = _getCanvasOffset();
        return Input.QUEUE.push({
          type: Input.T_MOUSE_DOWN,
          pos: [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
          button: ev.button,
          shiftInput: ev.shiftInput,
          ctrlInput: ev.ctrlInput,
          metaInput: ev.metaInput
        });
      };

      Input.onMouseUp = function(ev) {
        var canvasOffset;
        canvasOffset = _getCanvasOffset();
        return Input.QUEUE.push({
          type: Input.T_MOUSE_UP,
          pos: [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
          button: ev.button,
          shiftInput: ev.shiftInput,
          ctrlInput: ev.ctrlInput,
          metaInput: ev.metaInput
        });
      };

      Input.onInputDown = function(ev) {
        var key;
        key = ev.keyCode || ev.which;
        Input.QUEUE.push({
          type: Input.T_KEY_DOWN,
          key: key,
          shiftInput: ev.shiftInput,
          ctrlInput: ev.ctrlInput,
          metaInput: ev.metaInput
        });
        if (_hasFocus() && (!ev.ctrlInput && !ev.metaInput && ((key >= Input.K_LEFT && key <= Input.K_DOWN) || (key >= Input.K_0 && key <= Input.K_z) || (key >= Input.K_KP1 && key <= Input.K_KP9) || key === Input.K_SPACE || key === Input.K_TAB || key === Input.K_ENTER)) || key === Input.K_ALT || key === Input.K_BACKSPACE) {
          return ev.preventDefault();
        }
      };

      Input.onInputUp = function(ev) {
        return Input.QUEUE.push({
          type: Input.T_KEY_UP,
          key: ev.keyCode,
          shiftInput: ev.shiftInput,
          ctrlInput: ev.ctrlInput,
          metaInput: ev.metaInput
        });
      };

      Input.onMouseMove = function(ev) {
        var canvasOffset, currentPos, relativePos;
        canvasOffset = _getCanvasOffset();
        currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
        relativePos = [];
        if (lastPos.length) {
          relativePos = [lastPos[0] - currentPos[0], lastPos[1] - currentPos[1]];
        }
        Input.QUEUE.push({
          type: Input.T_MOUSE_MOTION,
          pos: currentPos,
          rel: relativePos,
          buttons: null,
          timestamp: ev.timeStamp
        });
        return lastPos = currentPos;
      };

      Input.onMouseScroll = function(ev) {
        var canvasOffset, currentPos;
        canvasOffset = _getCanvasOffset();
        currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
        return Input.QUEUE.push({
          type: Input.T_MOUSE_WHEEL,
          pos: currentPos,
          delta: ev.detail || (-ev.wheelDeltaY / 40)
        });
      };

      Input.onBeforeUnload = function(ev) {
        return Input.QUEUE.push({
          type: Input.T_QUIT
        });
      };

      return Input;

    })();
  });

}).call(this);
