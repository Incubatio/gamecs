// Generated by CoffeeScript 1.4.0
(function() {
  var __slice = [].slice;

  define(function(require) {
    var Matrix, Objects, Rect, Surface, isInit;
    Rect = require('rect');
    Objects = require('utils/objects');
    Matrix = require('utils/matrix');
    /**
    * A Surface represents a bitmap image with a fixed width and height. The
    * most important feature of a Surface is that they can be `blitted`
    * onto each other.
    *
    * @example
    * new gamecs.Surface([width, height])
    * new gamecs.Surface(width, height)
    * new gamecs.Surface(rect)
    * @constructor
    *
    * @param {Array} dimensions Array holding width and height
    */

    isInit = false;
    return Surface = (function() {
      /**
      * set to false to disable
      * pixel smoothing; this is, for example, useful for retro-style, low resolution graphics
      * where you don't want the browser to smooth them when scaling & drawing.
      */

      Surface.SURFACE_SMOOTHING = true;

      function Surface() {
        var args, args2, height, width;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (!isInit) {
          isInit = true;
          Objects.accessors(Surface.prototype, {
            /* @type gamecs.Rect
            */

            rect: {
              get: function() {
                return this.getRect();
              }
            },
            /* @ignore
            */

            context: {
              get: function() {
                return this._context;
              }
            },
            canvas: {
              get: function() {
                return this._canvas;
              }
            }
          });
        }
        args2 = Rect.normalizeArguments.apply(this, args);
        width = args2.left;
        height = args2.top;
        if (args[0].length === 1 && args[0] instanceof Rect) {
          width = args[0].width;
          height = args[0].height;
        }
        /* @ignore
        */

        this._matrix = [1, 0, 0, 1, 0, 0];
        /* @ignore
        */

        this._canvas = document.createElement("canvas");
        this._canvas.width = width;
        this._canvas.height = height;
        /* @ignore
        */

        this._blitAlpha = 1.0;
        /* @ignore
        */

        this._context = this._canvas.getContext('2d');
        if (Surface.SURFACE_SMOOTHING) {
          this._smooth();
        } else {
          this._noSmooth();
        }
      }

      /** @ignore
      */


      Surface.prototype._noSmooth = function() {
        /**
          disable image scaling
          see https:#developer.mozilla.org/en/Canvas_tutorial/Using_images#Controlling_image_scaling_behavior
          and https:#github.com/jbuck/processing-js/commit/65de16a8340c694cee471a2db7634733370b941c
        */
        this.context.mozImageSmoothingEnabled = false;
        this.context.webkitImageSmoothingEnabled = false;
      };

      /** @ignore
      */


      Surface.prototype._smooth = function() {
        this.context.mozImageSmoothingEnabled = true;
        return this.context.webkitImageSmoothingEnabled = true;
      };

      /**
      * Blits another Surface on this Surface. The destination where to blit to
      * can be given (or it defaults to the top left corner) as well as the
      * Area from the Surface which should be blitted (e.g., for cutting out parts of
      * a Surface).
      * 
      * @example
      * # blit flower in top left corner of display
      * displaySurface.blit(flowerSurface)
      * 
      * # position flower at 10/10 of display
      * displaySurface.blit(flowerSurface, [10, 10])
      * 
      * # ... `dest` can also be a rect whose topleft position is taken:
      * displaySurface.blit(flowerSurface, new gamecs.Rect([10, 10])
      * 
      * # only blit half of the flower onto the display
      * flowerRect = flowerSurface.rect
      * flowerRect = new gamecs.Rect([0,0], [flowerRect.width/2, flowerRect.height/2])
      * displaySurface.blit(flowerSurface, [0,0], flowerRect)
      * 
      * @param {gamecs.Surface} src The Surface which will be blitted onto this one
      * @param {gamecs.Rect|Array} dst the Destination x, y position in this Surface.
      *            If a Rect is given, it's top and left values are taken. If this argument
      *            is not supplied the blit happens at [0,0].
      * @param {gamesjs.Rect|Array} area the Area from the passed Surface which
      *            should be blitted onto this Surface.
      * @param {Number} compositionOperation how the source and target surfaces are composited together 
      *            one of: source-atop, source-in, source-out, source-over (default), destination-atop, 
      *            destination-in, destination-out, destination-over, lighter, copy, xor for an explanation 
      *            of these values see: http:#dev.w3.org/html5/2dcontext/#dom-context-2d-globalcompositeoperation
      * @returns {gamecs.Rect} Rect actually repainted FIXME actually return something?
      */


      Surface.prototype.blit = function(src, dest, area, compositeOperation) {
        var m, rArea, rDest, size, srcSize;
        if (dest instanceof Rect) {
          rDest = dest.clone();
          srcSize = src.getSize();
          if (!rDest.width) {
            rDest.width = srcSize[0];
          }
          if (!rDest.height) {
            rDest.height = srcSize[1];
          }
        } else if (dest && dest instanceof Array && dest.length === 2) {
          rDest = new Rect(dest, src.getSize());
        } else {
          rDest = new Rect([0, 0], src.getSize());
        }
        compositeOperation = compositeOperation || 'source-over';
        if (area instanceof Rect) {
          rArea = area;
        } else if (area && area instanceof Array && area.length === 2) {
          size = src.getSize();
          rArea = new Rect(area, [size[0] - area[0], size[1] - area[1]]);
        } else {
          rArea = new Rect([0, 0], src.getSize());
        }
        if (isNaN(rDest.left) || isNaN(rDest.top) || isNaN(rDest.width) || isNaN(rDest.height)) {
          throw new Error('[blit] bad parameters, destination is ' + rDest);
        }
        this.context.save();
        this.context.globalCompositeOperation = compositeOperation;
        /* first translate, then rotate
        */

        m = Matrix.translate(Matrix.identity(), rDest.left, rDest.top);
        m = Matrix.multiply(m, src._matrix);
        this.context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
        /* drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
        */

        this.context.globalAlpha = src._blitAlpha;
        this.context.drawImage(src.canvas, rArea.left, rArea.top, rArea.width, rArea.height, 0, 0, rDest.width, rDest.height);
        this.context.restore();
      };

      /** @returns {Number[]} the width and height of the Surface
      */


      Surface.prototype.getSize = function() {
        return [this.canvas.width, this.canvas.height];
      };

      /**
      * Obsolte, only here for compatibility.
      * @deprecated
      * @ignore
      * @returns {gamecs.Rect} a Rect of the size of this Surface
      */


      Surface.prototype.getRect = function() {
        return new Rect([0, 0], this.getSize());
      };

      /**
      * Fills the whole Surface with a color. Usefull for erasing a Surface.
      * @param {String} CSS color string, e.g. '#0d120a' or '#0f0' or 'rgba(255, 0, 0, 0.5)'
      * @param {gamecs.Rect} a Rect of the area to fill (defauts to entire surface if not specified)
      */


      Surface.prototype.fill = function(color, rect) {
        this.context.save();
        this.context.fillStyle = color || "#000000";
        if (rect === void 0) {
          rect = new Rect(0, 0, this.canvas.width, this.canvas.height);
        }
        this.context.fillRect(rect.left, rect.top, rect.width, rect.height);
        this.context.restore();
      };

      /* Clear the surface.
      */


      Surface.prototype.clear = function(rect) {
        var size;
        size = this.getSize();
        rect = rect || new Rect(0, 0, size[0], size[1]);
        this.context.clearRect(rect.left, rect.top, rect.width, rect.height);
      };

      /** @returns {gamecs.Surface} a clone of this surface
      */


      Surface.prototype.clone = function() {
        var newSurface;
        newSurface = new Surface(this.getRect().clone());
        newSurface.blit(this);
        return newSurface;
      };

      /** @returns {Number} current alpha value
      */


      Surface.prototype.getAlpha = function() {
        return 1 - this._blitAlpha;
      };

      /**
      * Set the alpha value for the whole Surface. When blitting the Surface on
      * a destination, the pixels will be drawn slightly transparent.
      * @param {Number} alpha value in range 0.0 - 1.0
      * @returns {Number} current alpha value
      */


      Surface.prototype.setAlpha = function(alpha) {
        if (isNaN(alpha) || alpha < 0 || alpha > 1) {
          return;
        }
        this._blitAlpha = 1 - alpha;
        return 1 - this._blitAlpha;
      };

      /**
      * The data must be represented in left-to-right order, row by row top to bottom,
      * starting with the top left, with each pixel's red, green, blue, and alpha components
      * being given in that order for each pixel.
      * @see http:#dev.w3.org/html5/2dcontext/#canvaspixelarray
      * @returns {ImageData} an object holding the pixel image data {data, width, height}
      */


      Surface.prototype.getImageData = function() {
        var size;
        size = this.getSize();
        return this.context.getImageData(0, 0, size[0], size[1]);
      };

      return Surface;

    })();
  });

}).call(this);
