// Generated by CoffeeScript 1.4.0
(function() {

  define(function(require) {
    var Img, Rect, SpriteSheet, Surface, TileMap;
    Surface = require('surface');
    Img = require('img');
    Rect = require('rect');
    SpriteSheet = require('spritesheet');
    /**
    * This Driver Supports tmxmap of a version >= 0.9
    * To upgrade your tmx map, simply download the last version of Tiled, open the file an re-export it :).
    * http://www.mapeditor.org/
    *
    * TileMap is a component that allow to compose map from re-usable image
    *
    * Tilemap can manage several layers
    * We can consider two different kind of layer, the visible layers and not visible layers (or data layers)
    * - Visible layers are merged into one Layer that will be rendered.
    * - Data layer can contain collision map, movable objects, mob positions, mob areas, ...
    * that directly fits the landscape, and thus can be reused from the application logic :).
    *
    *
    * Note: To keep this component re-usable data layer are simply loaded and then ignored until user
    * decide to get the layer (ex: map.layers.<layerName>)
    */

    return TileMap = (function() {
      /**
      * The width is expressed in tile (this is tmx standart)
      * @type integer
      */

      var height, size, tileHeight, tileSheet, tileWidth, width, _isColliding;

      width = null;

      /**
      * The height is expressed in tile
      * @type integer
      */


      height = null;

      /**
      * Tile width in px
      * @type integer
      */


      tileWidth = null;

      /**
      * Tile height in px
      * @type integer
      */


      tileHeight = null;

      /**
      * size in px = [width * tileWidth, height * tileHeight] 
      * @type Array
      */


      size = null;

      /**
      * contains the different image that compose the tile map
      * @type SpriteSheet
      */


      tileSheet = null;

      /**
      * @constructor
      * @this {Map}
      *
      * @param {Hash} data
      * @param {Hash} options
      */


      function TileMap(data, options) {
        var i, imageset, tileset, _i, _j, _len, _ref, _ref1;
        options = options || {};
        this.width = data.width;
        this.height = data.height;
        this.tileWidth = data.tilewidth;
        this.tileHeight = data.tileheight;
        this.size = [this.width * this.tileWidth, this.height * this.tileHeight];
        this.collisionLayerName = options.collisionLayerName || 'collision';
        this.tileSheet = new SpriteSheet();
        this.tileSheet.firstgid = data.tilesets[0].firstgid;
        _ref = data.tilesets;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          tileset = _ref[_i];
          imageset = Img.load(tileset.image);
          this.tileSheet.load(imageset, [tileset.tilewidth, tileset.tileheight]);
        }
        this.layers = {};
        for (i = _j = 0, _ref1 = data.layers.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          this.layers[data.layers[i].name] = data.layers[i];
        }
      }

      /**
      * @param {interger} gid
      * @return {array}
      */


      TileMap.prototype.gid2pos = function(gid) {
        var getX, x, y, _ref;
        gid -= 1;
        getX = function(i, width) {
          var _ref;
          return (_ref = i % width === 0) != null ? _ref : width - {
            1: (i % width) - 1
          };
        };
        x = (_ref = gid === 0) != null ? _ref : {
          0: getX(gid + 1, this.width)
        };
        y = Math.floor(gid / this.width);
        return [(x + 1) * this.tileWidth, y * this.tileHeight];
      };

      /**
      * @param {integer} gid
      * @return {Rect}
      */


      TileMap.prototype.gid2rect = function(gid) {
        return new gamecs.Rect(this.gid2pos(gid), [this.tileWidth, this.tileHeight]);
      };

      /**
      * @param {integer} x
      * @param {integer} y
      * @return {integer}
      */


      TileMap.prototype.pos2gid = function(x, y) {
        x = Math.floor(x / this.tileWidth);
        y = Math.floor(y / this.tileHeight);
        return (y * this.width) + x;
      };

      /**
      * @param {integer} gid
      * @return {Img}
      */


      TileMap.prototype.getTile = function(gid) {
        return this.tileSheet.get(gid - this.tileSheet.firstgid);
      };

      /**
      * @param {integer} x
      * @param {integer} y
      * @return {boolean}
      */


      TileMap.prototype.isOutOfBounds = function(x, y) {
        return x <= 0 || x >= this.size[0] || y <= 0 || y >= this.size[1];
      };

      /**
      * For collision layer
      *
      * @param {integer} x
      * @param {integer} y
      * @return {boolean}
      */


      _isColliding = function(x, y, collisionLayerName) {
        if (collisionLayerName === void 0) {
          collisionLayerName = this.collisionLayerName;
        }
        if (this.isOutOfBounds(x, y)) {
          return true;
        }
        return !!this.layers[this.collisionLayerName].data[this.pos2gid(x, y)];
      };

      /**
      * @param {Rect}
      * @return boolean
      */


      TileMap.prototype.isColliding = function(rect) {
        return _isColliding(rect.left, rect.top) || _isColliding(rect.left + rect.width, rect.top) || _isColliding(rect.left, rect.top + rect.height) || _isColliding(rect.left + rect.width, rect.top + rect.height);
      };

      /**
      * For Sprite layer, return each tile as object: {pos: [x, y], card: [a, b], gid: i, image: "path/to/image"}
      *
      * @return {Array}
      */


      TileMap.prototype.getTiles = function() {
        var result;
        result = [];
        return result;
      };

      /**
      * Prepare a grid of visible images for visible Layers
      */


      TileMap.prototype.prepareLayers = function() {
        var gid, image, key, layer, rect, surface, x, y, _i, _j, _ref, _ref1, _results;
        _results = [];
        for (key in this.layers) {
          layer = this.layers[key];
          if (layer.properties === void 0 || layer.properties.visible !== false) {
            surface = new Surface(this.size[0], this.size[1]);
            for (y = _i = 0, _ref = this.height; 0 <= _ref ? _i < _ref : _i > _ref; y = 0 <= _ref ? ++_i : --_i) {
              for (x = _j = 0, _ref1 = this.width; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
                rect = new Rect(x * this.tileWidth, y * this.tileHeight, this.tileWidth, this.tileHeight);
                gid = layer.data[(y * this.width) + x];
                if (gid !== 0) {
                  if (gid) {
                    image = this.getTile(gid);
                    surface.blit(image, rect);
                  } else {
                    console.log('bug', x, y, gid);
                  }
                }
              }
            }
            _results.push(this.layers[key].image = surface);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      return TileMap;

    })();
  });

}).call(this);
