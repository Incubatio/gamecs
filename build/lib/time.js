// Generated by CoffeeScript 1.4.0
(function() {

  define(function(require) {
    /*
       * @fileoverview
       * Provides tools for game time managment.
       *
       * This is very different from how PyGame works. We can not
       * pause the execution of the script in Browser JavaScript, so what
       * we do you do is write a main function which contains the code
       * you would put into your main loop and pass that to `gamecs.time.interval()`:
       *
       * @example
       * // call function `tick` as fast as the browser thinks is appropriate
       *  gamecs.time.interval(tick);
       * // call the function `tick` maximally 20 times per second
       *  gamecs.time.interval(tick, 20);
    */

    var CALLBACKS, CALLBACKS_LASTCALL, STARTTIME, TIMER_LASTCALL, Time, perInterval, reqAniFrameRecursive, reqAnimationFrame;
    TIMER_LASTCALL = null;
    CALLBACKS = {};
    CALLBACKS_LASTCALL = {};
    STARTTIME = null;
    perInterval = function() {
      var callbackWrapper, fpsInput, lastCalls, msNow, msWaited, _results;
      msNow = Date.now();
      lastCalls = CALLBACKS_LASTCALL;
      callbackWrapper = function(fnInfo) {
        return fnInfo.callback(msWaited);
      };
      _results = [];
      for (fpsInput in lastCalls) {
        if (!lastCalls[fpsInput]) {
          CALLBACKS_LASTCALL[fpsInput] = msNow;
        }
        msWaited = msNow - lastCalls[fpsInput];
        if (fpsInput <= msWaited) {
          CALLBACKS_LASTCALL[fpsInput] = msNow;
          _results.push(CALLBACKS[fpsInput].forEach(callbackWrapper, this));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    /**
    * `window` is not accessible in webworker (would lead to TypeError)
    * @@ this cross-browser fuckery has to go away ASAP.
    */

    reqAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || null;
    reqAniFrameRecursive = function() {
      perInterval();
      return reqAnimationFrame(reqAniFrameRecursive);
    };
    return Time = (function() {

      function Time() {}

      /** @ignore
      */


      Time.init = function() {
        this.STARTTIME = Date.now();
        if (reqAnimationFrame) {
          return reqAnimationFrame(reqAniFrameRecursive);
        } else {
          return setInterval(perInterval, 10);
        }
      };

      /**
      * Call a function as fast as the browser thinks is good for an animation.
      *
      * Alternatively, the desired "frames per second" (fps) can be passed as
      * the second argument. This will limit the calls to the function to happen
      * at most this often per second. "fps" is thus a colloquial term for
      * "callback frequency per second".
      *
      * If you do not specify a required callback frequency but let the browser
      * decided how often the function should get called, then beware that the browser
      * can schedule your function to only be called as rarely as once per second
      * (for example, if the browser window is not visible).
      *
      * @param {Function} fn the function to be called
      * @param {Number} fps optional callback frequency per second
      * @param {Object} thisObj optional context for callback function
      */


      Time.interval = function(fn, fps, thisObj) {
        if (thisObj === void 0 && isNaN(fps)) {
          thisObj = fps;
          fps = void 0;
        }
        return this.fpsCallback(fn, thisObj, fps);
      };

      /**
      * This function is deprecated in favor of `gamecs.time.interval`
      * @see #interval
      * @param {Function} fn the function to call back
      * @param {Object} thisObj `this` will be set to that object when executing the callback function
      * @param {Number} fps specify the framerate by which you want the callback to be called. (e.g. 30 = 30 times per seconds). default: 60
      * @deprecated
      * @ignore
      */


      Time.fpsCallback = function(fn, thisObj, fps) {
        if (fps === void 0) {
          fps = 60;
        }
        fps = parseInt(1000 / fps, 10);
        CALLBACKS[fps] = CALLBACKS[fps] || [];
        CALLBACKS_LASTCALL[fps] = CALLBACKS_LASTCALL[fps] || 0;
        return CALLBACKS[fps].push({
          'rawFn': fn,
          'callback': function(msWaited) {
            return fn.apply(thisObj, [msWaited]);
          }
        });
      };

      /**
      * @param {Function} callback the function delete
      * @param {Number} fps
      * @deprecated
      * @ignore
      */


      Time.deleteCallback = function(callback, fps) {
        var callbacks, result;
        result = null;
        fps = parseInt(1000 / fps, 10);
        callbacks = CALLBACKS[fps];
        if (callbacks) {
          CALLBACKS[fps] = callbacks.filter(function(fnInfo, idx) {
            return result = fnInfo.rawFn !== callback;
          });
        }
        return result;
      };

      return Time;

    })();
  });

}).call(this);
