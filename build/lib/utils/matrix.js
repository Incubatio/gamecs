// Generated by CoffeeScript 1.4.0

/**
* @fileoverview Matrix manipulation, used by GameJs itself. You
* probably do not need this unless you manipulate a Context's transformation
* matrix yourself.
*/


(function() {

  define(function(require) {
    "use strict";

    var Matrix;
    return Matrix = (function() {

      function Matrix() {}

      /** @returns {Array} [1, 0, 0, 1, 0, 0]
      */


      Matrix.identity = function() {
        return [1, 0, 0, 1, 0, 0];
      };

      /**
      * TODO: Only add one dimention matrix, and only support array of 7 element or less
      * what does it really calculate ?
      *
      * @param {Array} matrix
      * @param {Array} matrix
      * @returns {Array} matrix sum
      */


      Matrix.add = function(m1, m2) {
        return [m1[0] + m2[0], m1[1] + m2[1], m1[2] + m2[2], m1[3] + m2[3], m1[4] + m2[4], m1[5] + m2[5], m1[6] + m2[6]];
      };

      /**
      * TODO: WTF is the code below, require one dimention matrix of at lease 3 elements each.
      * what does it really calculate ?
      *
      * @param {Array} matrix A
      * @param {Array} matrix B
      * @returns {Array} matrix product
      */


      Matrix.multiply = function(m1, m2) {
        return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
      };

      /**
      * @param {Array} matrix
      * @param {Array} matrix
      * @returns {Array} matrix sum
      */


      Matrix.add2 = function(m1, m2) {
        var i, j, res, _i, _j, _ref, _ref1;
        if (!(m1[0] instanceof Array)) {
          m1 = [m1];
        }
        if (!(m2[0] instanceof Array)) {
          m2 = [m2];
        }
        if (m1.length !== m2.length && m1[0].length !== m2[0].length) {
          throw "error: incompatible sizes";
        }
        res = [];
        for (i = _i = 0, _ref = m1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          res[i] = [];
          for (j = _j = 0, _ref1 = m1[0].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
            res[i][j] = m1[i][j] + m2[i][j];
          }
        }
        return res;
      };

      /**
      * @param {Array} matrix
      * @param {Array} matrix
      * @returns {Array} matrix sum
      */


      Matrix.multiply2 = function(m1, m2) {
        var i, j, k, res, s, _i, _ref, _results;
        if (!(m1[0] instanceof Array)) {
          m1 = [m1];
        }
        if (!(m2[0] instanceof Array)) {
          m2 = m2.map(function(i) {
            return [i];
          });
        }
        if (m1[0].length !== m2.length) {
          throw "error: incompatible sizes";
        }
        res = [];
        _results = [];
        for (i = _i = 0, _ref = m1.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          res[i] = [];
          _results.push((function() {
            var _j, _k, _ref1, _ref2, _results1;
            _results1 = [];
            for (j = _j = 0, _ref1 = m2[0].length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
              s = 0;
              for (k = _k = 0, _ref2 = m1[0].length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; k = 0 <= _ref2 ? ++_k : --_k) {
                s += m1[i][k] * m2[k][j];
              }
              _results1.push(res[i][j] = s);
            }
            return _results1;
          })());
        }
        return _results;
      };

      /**
      * @param {Array} matrix
      * @param {Number} dx
      * @param {Number} dy
      * @returns {Array} translated matrix
      */


      Matrix.translate = function(m1, dx, dy) {
        return Matrix.multiply(m1, [1, 0, 0, 1, dx, dy]);
      };

      /**
      * @param {Array} matrix
      * @param {Number} angle in radians
      * @returns {Array} rotated matrix
      */


      Matrix.rotate = function(m1, angle) {
        var cos, sin;
        sin = Math.sin(angle);
        cos = Math.cos(angle);
        return Matrix.multiply(m1, [cos, sin, -sin, cos, 0, 0]);
      };

      /**
      * @param {Array} matrix
      * @returns {Number} rotation in radians
      */


      Matrix.rotation = function(m1) {
        return Math.atan2(m1[1], m1[0]);
      };

      /**
      * @param {Array} matrix
      * @param {Array} vector [a, b]
      * @returns {Array} scaled matrix
      */


      Matrix.scale = function(m1, svec) {
        var sx, sy;
        sx = svec[0];
        sy = svec[1];
        return Matrix.multiply(m1, [sx, 0, 0, sy, 0, 0]);
      };

      return Matrix;

    })();
  });

}).call(this);
