// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var System, components, gamecs, systems;
    gamecs = require('gamecs');
    components = require('components');
    System = (function() {

      function System(options) {
        var k, v;
        for (k in options) {
          v = options[k];
          this[k] = v;
        }
      }

      return System;

    })();
    return systems = {
      Rendering: (function(_super) {
        var clear;

        __extends(_Class, _super);

        function _Class() {
          this.scaleRate = 1.5;
        }

        _Class.prototype.update = function(entity, ms) {
          var component;
          if (entity.components.Animated) {
            component = entity.components.Animated;
            if (!component.animation.currentAnimation) {
              return component.image = component.animation.entitySheet.get(0);
            }
          }
        };

        _Class.prototype.draw = function(entity, surface) {
          var component;
          if (entity.dirty && entity.components.Visible) {
            component = entity.components.Visible;
            if (component.image) {
              surface.clear(entity.oldRect);
              surface.fill('#fff', entity.rect);
              surface.blit(component.image, entity.rect);
            } else {
              if (entity.oldRect) {
                entity.oldRect.topleft = [entity.oldRect.left - 1, entity.oldRect.top - 1];
                surface.clear(entity.oldRect);
              }
              gamecs.Draw.circle(surface, '#fff', entity.rect.topleft, 1, 0);
            }
            return entity.dirty = false;
          }
        };

        clear = function(sprite, surface, camera) {};

        return _Class;

      })(System),
      Rotation: (function(_super) {

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.update = function(sprite) {
          var size;
          if (!sprite.components.Visible.originalImage) {
            sprite.components.Visible.originalImage = sprite.components.Visible.image;
          }
          if (sprite.components.Rotative) {
            sprite.components.Rotative.rotation += sprite.components.Rotative.rotationSpeed;
            if (sprite.components.Rotative.rotation >= 360) {
              sprite.components.Rotative.rotation -= 360;
            }
            sprite.components.Visible.image = gamecs.Transform.rotate(sprite.components.Visible.originalImage, sprite.components.Rotative.rotation);
            size = sprite.components.Visible.image.getSize();
            sprite.rect.width = size[0];
            sprite.rect.height = size[1];
            return sprite.dirty = true;
          }
        };

        return _Class;

      })(System),
      Collision: (function(_super) {
        var _isColliding, _spriteCollide;

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _spriteCollide = function(entity, entities) {
          var collisions, entity2, _i, _len;
          collisions = [];
          for (_i = 0, _len = entities.length; _i < _len; _i++) {
            entity2 = entities[_i];
            if (entity.uid !== entity2.uid) {
              if (entity.rect.collideRect(entity2.rect)) {
                collisions.push(entity2);
              }
            }
          }
          return collisions;
        };

        _isColliding = function(entity, entities) {
          var entity2, res, _i, _len;
          res = false;
          for (_i = 0, _len = entities.length; _i < _len; _i++) {
            entity2 = entities[_i];
            if (entity.rect.collideRect(entity2.rect)) {
              res = true;
              break;
            }
          }
          return res;
        };

        _Class.prototype.update = function(entity, ms) {
          var collisions, component, entity2, weapon, x, y, _i, _len;
          if (entity.components.Collidable && entity.components.Mobile) {
            component = entity.components.Mobile;
            if (component.moveX !== 0 || component.moveY !== 0) {
              x = component.moveX * component.speed;
              y = component.moveY * component.speed;
              collisions = _spriteCollide(entity, this.entities);
              if (collisions.length > 0) {
                for (_i = 0, _len = collisions.length; _i < _len; _i++) {
                  entity2 = collisions[_i];
                  if (entity2.components.Weaponized) {
                    weapon = true;
                    entity.kill = true;
                  }
                  if (entity.components.Weaponized) {
                    entity2.kill = true;
                  }
                }
                if (weapon) {

                } else {
                  entity.rect = entity.oldRect.clone();
                  entity.rect.moveIp(x, 0);
                  collisions = _spriteCollide(entity, this.entities);
                  if (collisions.length > 0) {
                    x = 0;
                    entity.rect = entity.oldRect.clone();
                  }
                  entity.rect.moveIp(0, y);
                  collisions = _spriteCollide(entity, this.entities);
                  if (collisions.length > 0) {
                    y = 0;
                    entity.rect = entity.oldRect.clone();
                  }
                  entity.rect = entity.oldRect.clone();
                  if (x !== 0 || y !== 0) {
                    return entity.rect.moveIp(x, y);
                  } else {
                    return entity.dirty = false;
                  }
                }
              }
            }
          }
        };

        return _Class;

      })(System),
      Movement: (function(_super) {

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.update = function(entity, ms) {
          var component, x, y;
          if (entity.components.Mobile) {
            component = entity.components.Mobile;
            if (component.moveX !== 0 || component.moveY !== 0) {
              entity.oldRect = entity.rect.clone();
              x = component.moveX * component.speed;
              y = component.moveY * component.speed;
              entity.dirty = true;
              return entity.rect.moveIp(x, y);
            }
          }
        };

        return _Class;

      })(System),
      Weapon: (function(_super) {

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.update = function(sprite, ms, director) {
          var animation, collisions, k, sprite2, weapon;
          if (sprite.Weaponized && sprite.attacking) {
            weapon = director.scene.sprites[sprite.weapon];
            if (!weapon.animation.currentAnimation) {
              console.log(sprite.animation.currentAnimation);
              animation = !sprite.animation.currentAnimation || sprite.animation.currentAnimation === "pause" ? "down" : sprite.animation.currentAnimation;
              weapon.animation.start(animation);
            }
            weapon.oldImage = void 0;
            collisions = gamecs.sprite.spriteCollide(weapon, director.scene.spriteGroup);
            for (k in collisions) {
              sprite2 = collisions[k];
              if (sprite2.Destructible) {
                director.surface.clear(sprite2.rect);
                sprite2.kill();
              }
            }
            if (weapon.animation.finished) {
              sprite.attacking = false;
              weapon.animation.currentAnimation = void 0;
              weapon.dirty = false;
              return weapon.rect.moveIp([-(sprite.rect.left + sprite.rect.width * 2), -(sprite.rect.top + sprite.rect.height * 2)]);
            } else {
              weapon.dirty = true;
              weapon.rect.moveIp(sprite.rect.left - weapon.rect.left, sprite.rect.top - weapon.rect.top);
              return weapon.image = weapon.animation.update(60);
            }
          }
        };

        return _Class;

      })(System)
    };
  });

}).call(this);
