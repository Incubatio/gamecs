// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define(function(require) {
    var System, components, gamecs, systems;
    gamecs = require('gamecs');
    components = require('components');
    System = (function() {

      function System(options) {
        var k, v;
        for (k in options) {
          v = options[k];
          this[k] = v;
        }
      }

      return System;

    })();
    return systems = {
      Rendering: (function(_super) {

        __extends(_Class, _super);

        _Class.prototype.offset = [0, 0];

        function _Class() {
          this.scaleRate = 1.5;
        }

        _Class.prototype.update = function(entity, ms) {
          var component;
          if (entity.animation) {
            component = entity.components.Animated;
            return entity.image = entity.animation.update(ms);
          }
        };

        _Class.prototype.draw = function(entity, surface) {
          if (entity.image) {
            surface.clear(entity.oldRect.move(this.offset));
            surface.blit(entity.image, entity.rect.move(this.offset));
            return entity.dirty = false;
          }
        };

        return _Class;

      })(System),
      Rotation: (function(_super) {

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.update = function(sprite) {
          var size;
          if (!sprite.components.Visible.originalImage) {
            sprite.components.Visible.originalImage = sprite.components.Visible.image;
          }
          if (sprite.components.Rotative) {
            sprite.components.Rotative.rotation += sprite.components.Rotative.rotationSpeed;
            if (sprite.components.Rotative.rotation >= 360) {
              sprite.components.Rotative.rotation -= 360;
            }
            sprite.components.Visible.image = gamecs.Transform.rotate(sprite.components.Visible.originalImage, sprite.components.Rotative.rotation);
            size = sprite.components.Visible.image.getSize();
            sprite.rect.width = size[0];
            sprite.rect.height = size[1];
            return sprite.dirty = true;
          }
        };

        return _Class;

      })(System),
      Collision: (function(_super) {

        __extends(_Class, _super);

        /*
              _isColliding: (entity, entities) ->
                res = false
                for entity2 in entities
                  if entity.rect.collideRect(entity2.rect)
                    res = true
                    break
                return res
        */


        /** function used to detect the collision 
        * @param {Object} entity
        * @param {Array} entities
        * @return {Array}
        */


        _Class.prototype.spriteCollide = function() {
          return [];
        };

        function _Class() {
          _Class.__super__.constructor.apply(this, arguments);
          this.spriteCollide = this._spriteCollide;
        }

        _Class.prototype._spriteCollide = function(entity, entities) {
          var collisions, entity2, _i, _len;
          collisions = [];
          for (_i = 0, _len = entities.length; _i < _len; _i++) {
            entity2 = entities[_i];
            if (entity.uid !== entity2.uid) {
              if (entity.rect.collideRect(entity2.rect)) {
                collisions.push(entity2);
              }
            }
          }
          return collisions;
        };

        _Class.prototype.update = function(entity, ms) {
          var collisions, component, entity2, x, y, _i, _len;
          if (entity.components.Collidable && entity.components.Mobile) {
            component = entity.components.Mobile;
            if (component.moveX !== 0 || component.moveY !== 0) {
              x = component.moveX * component.speed;
              y = component.moveY * component.speed;
              collisions = this.spriteCollide(entity, this.entities);
              if (collisions.length > 0) {
                for (_i = 0, _len = collisions.length; _i < _len; _i++) {
                  entity2 = collisions[_i];
                  entity.trigger('collision', {
                    to: entity2
                  });
                }
                entity.rect = entity.oldRect.clone();
                entity.rect.moveIp(x, 0);
                collisions = this.spriteCollide(entity, this.entities);
                if (collisions.length > 0) {
                  x = 0;
                  entity.rect = entity.oldRect.clone();
                }
                entity.rect.moveIp(0, y);
                collisions = this.spriteCollide(entity, this.entities);
                if (collisions.length > 0) {
                  y = 0;
                  entity.rect = entity.oldRect.clone();
                }
                entity.rect = entity.oldRect.clone();
                if (x !== 0 || y !== 0) {
                  return entity.rect.moveIp(x, y);
                } else {
                  return entity.dirty = false;
                }
              }
            }
          }
        };

        return _Class;

      })(System),
      Movement: (function(_super) {

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.update = function(entity, ms) {
          var component, multiplier, x, y;
          if (entity.components.Mobile) {
            component = entity.components.Mobile;
            if (component.moveX !== 0 || component.moveY !== 0) {
              entity.oldRect = entity.rect.clone();
              multiplier = component.moveX !== 0 && component.moveY !== 0 ? 1 : 1.41;
              x = Math.round(component.moveX * component.speed * multiplier);
              y = Math.round(component.moveY * component.speed * multiplier);
              entity.dirty = true;
              return entity.rect.moveIp(x, y);
            }
          }
        };

        return _Class;

      })(System),
      Weapon: (function(_super) {

        __extends(_Class, _super);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.prototype.update = function(sprite, ms, director) {
          var animation, collisions, k, sprite2, weapon;
          if (sprite.Weaponized && sprite.attacking) {
            weapon = director.scene.sprites[sprite.weapon];
            if (!weapon.animation.currentAnimation) {
              console.log(sprite.animation.currentAnimation);
              animation = !sprite.animation.currentAnimation || sprite.animation.currentAnimation === "pause" ? "down" : sprite.animation.currentAnimation;
              weapon.animation.start(animation);
            }
            weapon.oldImage = void 0;
            collisions = gamecs.sprite.spriteCollide(weapon, director.scene.spriteGroup);
            for (k in collisions) {
              sprite2 = collisions[k];
              if (sprite2.Destructible) {
                director.surface.clear(sprite2.rect);
                sprite2.kill();
              }
            }
            if (weapon.animation.finished) {
              sprite.attacking = false;
              weapon.animation.currentAnimation = void 0;
              weapon.dirty = false;
              return weapon.rect.moveIp([-(sprite.rect.left + sprite.rect.width * 2), -(sprite.rect.top + sprite.rect.height * 2)]);
            } else {
              weapon.dirty = true;
              weapon.rect.moveIp(sprite.rect.left - weapon.rect.left, sprite.rect.top - weapon.rect.top);
              return weapon.image = weapon.animation.update(60);
            }
          }
        };

        return _Class;

      })(System)
    };
  });

}).call(this);
