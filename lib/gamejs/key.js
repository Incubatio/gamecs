// Generated by CoffeeScript 1.4.0
(function() {

  define(function(require) {
    var Display, Key, lastPos;
    Display = require('display');
    /**
    * @fileoverview Methods for polling mouse and keyboard.
    *
    * Call `gamejs.event.get()` in your main loop to get a list of events that happend
    * since your last call.
    *
    * Note that some events, which would trigger a default browser action, are prevented
    * from triggering their default behaviour if and only if the game's display canvas has
    * focus (the game gets focus if the user clicked on the game).
    *
    * All events have a type identifier. This event type is in between the values
    * of NOEVENT and NUMEVENTS. Each event has a constant in `gamejs.event.*` 
    * All user defined events can have the value of USEREVENT or higher.
    * Make sure your custom event ids* follow this system.
    * 
    * A pattern for using the event loop: your main game function (tick in this example)
    * is being called by [gamejs.time.interval()](../time/#interval).
    * Inside tick we call [gamejs.event.get()](#get) for a list of events that happened since the last
    * tick and we loop over each event and act on the event properties.
    *
    * @example
    *     events = gamejs.event.get()
    *     events.forEach(function(event) {
    *        if (event.type == gamejs.event.MOUSE_UP) {
    *          gamejs.log(event.pos, event.button)
    *        } else if (event.type == gamejs.event.KEY_UP) {
    *          gamejs.log(event.key)
    *        }
    *     })
    *
    */

    lastPos = [];
    return Key = (function() {

      function Key() {}

      /* key constants
      */


      Key.K_LEFT = 37;

      Key.K_UP = 38;

      Key.K_RIGHT = 39;

      Key.K_DOWN = 40;

      Key.K_BACKSPACE = 8;

      Key.K_TAB = 9;

      Key.K_ENTER = 13;

      Key.K_SHIFT = 16;

      Key.K_CTRL = 17;

      Key.K_ALT = 18;

      Key.K_ESC = 27;

      Key.K_SPACE = 32;

      Key.K_0 = 48;

      Key.K_1 = 49;

      Key.K_2 = 50;

      Key.K_3 = 51;

      Key.K_4 = 52;

      Key.K_5 = 53;

      Key.K_6 = 54;

      Key.K_7 = 55;

      Key.K_8 = 56;

      Key.K_9 = 57;

      Key.K_a = 65;

      Key.K_b = 66;

      Key.K_c = 67;

      Key.K_d = 68;

      Key.K_e = 69;

      Key.K_f = 70;

      Key.K_g = 71;

      Key.K_h = 72;

      Key.K_i = 73;

      Key.K_j = 74;

      Key.K_k = 75;

      Key.K_l = 76;

      Key.K_m = 77;

      Key.K_n = 78;

      Key.K_o = 79;

      Key.K_p = 80;

      Key.K_q = 81;

      Key.K_r = 82;

      Key.K_s = 83;

      Key.K_t = 84;

      Key.K_u = 85;

      Key.K_v = 86;

      Key.K_w = 87;

      Key.K_x = 88;

      Key.K_y = 89;

      Key.K_z = 90;

      Key.K_KP1 = 97;

      Key.K_KP2 = 98;

      Key.K_KP3 = 99;

      Key.K_KP4 = 100;

      Key.K_KP5 = 101;

      Key.K_KP6 = 102;

      Key.K_KP7 = 103;

      Key.K_KP8 = 104;

      Key.K_KP9 = 105;

      /* event type constants
      */


      Key.NOEVENT = 0;

      Key.NUMEVENTS = 32000;

      Key.QUIT = 0;

      Key.KEY_DOWN = 1;

      Key.KEY_UP = 2;

      Key.MOUSE_MOTION = 3;

      Key.MOUSE_UP = 4;

      Key.MOUSE_DOWN = 5;

      Key.MOUSE_WHEEL = 6;

      Key.USEREVENT = 2000;

      Key.WORKER = 1000;

      Key.WORKER_RESULT = 1001;

      /* @ignore
      */


      Key.WORKER_ERROR = 1002;

      /* @ignore
      */


      Key.WORKER_ALIVE = 1003;

      /* @ignore
      */


      Key.WORKER_LOG = 1004;

      Key.QUEUE = [];

      /**
      * Get all events from the event queue
      * @returns {Array}
      */


      Key.get = function(eventTypes) {
        var result;
        if (eventTypes === void 0) {
          return Key.QUEUE.splice(0, Key.QUEUE.length);
        } else {
          if (!(eventTypes instanceof Array)) {
            eventTypes = [eventTypes];
          }
          result = [];
          Key.QUEUE = Key.QUEUE.filter(function(event) {
            if (eventTypes.indexOf(event.type) === -1) {
              return true;
            }
            result.push(event);
            return false;
          });
          return result;
        }
      };

      /**
      * Get the newest event of the event queue
      * @returns {gamejs.event.Event}
      */


      Key.poll = function() {
        return Key.QUEUE.pop();
      };

      /**
      * Post an event to the event queue.
      * @param {gamejs.event.Event} userEvent the event to post to the queue
      */


      Key.post = function(userEvent) {
        if (userEvent.type === this.WORKER_RESULT && gamejs.worker.inWorker === true) {
          gamejs.worker._messageMain(userEvent);
        } else if (userEvent.type === this.WORKER && gamejs.worker.inWorker === false) {
          if (!userEvent.worker || !userEvent.worker.post) {
            throw new Error('Missing "worker" property on event');
          }
          userEvent.worker.post(userEvent.data);
        } else {
          Key.QUEUE.push(userEvent);
        }
      };

      /**
      * Remove all events from the queue
      */


      Key.clear = function() {
        return Key.QUEUE = [];
      };

      /**
      * Holds all information about an event.
      * @class
      */


      Key.Event = function() {
        /* The type of the event. e.g., gamejs.event.QUIT, KEYDOWN, MOUSEUP.
        */
        this.type = null;
        /* key the keyCode of the key. compare with gamejs.event.K_a, gamejs.event.K_b,...
        */

        this.key = null;
        /* relative movement for a mousemove event
        */

        this.rel = null;
        /* the number of the mousebutton pressed
        */

        this.button = null;
        /* pos the position of the event for mouse events
        */

        return this.pos = null;
      };

      /**
      * @ignore
      */


      Key.init = function() {
        var canvas;
        lastPos = [];
        /**
        * IEFIX does not support addEventListener on document itself
        * MOZFIX but in moz & opera events don't reach body if mouse outside window or on menubar
        */

        canvas = Display.getSurface()._canvas;
        document.addEventListener('mousedown', this.onMouseDown, false);
        document.addEventListener('mouseup', this.onMouseUp, false);
        document.addEventListener('keydown', this.onKeyDown, false);
        document.addEventListener('keyup', this.onKeyUp, false);
        canvas.addEventListener('mousemove', this.onMouseMove, false);
        canvas.addEventListener('mousewheel', this.onMouseScroll, false);
        /** 
        * MOZFIX
        * https://developer.mozilla.org/en/Code_snippets/Miscellaneous#Detecting_mouse_wheel_events
        */

        canvas.addEventListener('DOMMouseScroll', this.onMouseScroll, false);
        return canvas.addEventListener('beforeunload', this.onBeforeUnload, false);
        /* anonymous functions as event handlers = memory leak, see MDC:elementAddEventListener
        */

      };

      Key.onMouseDown = function(ev) {
        var canvasOffset;
        canvasOffset = Display._getCanvasOffset();
        return Key.QUEUE.push({
          type: Key.MOUSE_DOWN,
          pos: [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
          button: ev.button,
          shiftKey: ev.shiftKey,
          ctrlKey: ev.ctrlKey,
          metaKey: ev.metaKey
        });
      };

      Key.onMouseUp = function(ev) {
        var canvasOffset;
        canvasOffset = Display._getCanvasOffset();
        return Key.QUEUE.push({
          type: Key.MOUSE_UP,
          pos: [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]],
          button: ev.button,
          shiftKey: ev.shiftKey,
          ctrlKey: ev.ctrlKey,
          metaKey: ev.metaKey
        });
      };

      Key.onKeyDown = function(ev) {
        var key;
        key = ev.keyCode || ev.which;
        Key.QUEUE.push({
          type: Key.KEY_DOWN,
          key: key,
          shiftKey: ev.shiftKey,
          ctrlKey: ev.ctrlKey,
          metaKey: ev.metaKey
        });
        if (Display._hasFocus() && (!ev.ctrlKey && !ev.metaKey && ((key >= Key.K_LEFT && key <= Key.K_DOWN) || (key >= Key.K_0 && key <= Key.K_z) || (key >= Key.K_KP1 && key <= Key.K_KP9) || key === Key.K_SPACE || key === Key.K_TAB || key === Key.K_ENTER)) || key === Key.K_ALT || key === Key.K_BACKSPACE) {
          return ev.preventDefault();
        }
      };

      Key.onKeyUp = function(ev) {
        return Key.QUEUE.push({
          type: Key.KEY_UP,
          key: ev.keyCode,
          shiftKey: ev.shiftKey,
          ctrlKey: ev.ctrlKey,
          metaKey: ev.metaKey
        });
      };

      Key.onMouseMove = function(ev) {
        var canvasOffset, currentPos, relativePos;
        canvasOffset = Display._getCanvasOffset();
        currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
        relativePos = [];
        if (lastPos.length) {
          relativePos = [lastPos[0] - currentPos[0], lastPos[1] - currentPos[1]];
        }
        Key.QUEUE.push({
          type: Key.MOUSE_MOTION,
          pos: currentPos,
          rel: relativePos,
          buttons: null,
          timestamp: ev.timeStamp
        });
        return lastPos = currentPos;
      };

      Key.onMouseScroll = function(ev) {
        var canvasOffset, currentPos;
        canvasOffset = Display._getCanvasOffset();
        currentPos = [ev.clientX - canvasOffset[0], ev.clientY - canvasOffset[1]];
        return Key.QUEUE.push({
          type: Key.MOUSE_WHEEL,
          pos: currentPos,
          delta: ev.detail || (-ev.wheelDeltaY / 40)
        });
      };

      Key.onBeforeUnload = function(ev) {
        return Key.QUEUE.push({
          type: Key.QUIT
        });
      };

      return Key;

    })();
  });

}).call(this);
