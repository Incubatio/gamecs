// Generated by CoffeeScript 1.4.0
(function() {

  define(function(require) {
    var Objects, Surface, SurfaceArray, data, imageData, size;
    Surface = require('surface');
    Objects = require('utils/objects');
    /**
    * @fileoverview Fast pixel access.
    *
    * @example
    *
    *   // create array from display surface
    *   srfArray = new SurfaceArray(display)
    *   // direct pixel access
    *   srfArray.set(50, 100, [255, 0, 0, 100])
    *   console.log(srfArray.get(30, 50))
    *   // blit modified array back to display surface
    *   blitArray(display, srfArray)
    */

    size = null;
    data = null;
    imageData = null;
    return SurfaceArray = (function() {
      /**
      * Directly copy values from an array into a Surface.
      *
      * This is faster than blitting the `surface` property on a SurfaceArray
      *
      * The array must be the same dimensions as the Surface and will completely
      * replace all pixel values.
      * @param {gamejs.Surface} surface
      * @param {gamejs.surfacearray.SurfaceArray} surfaceArray
      */

      SurfaceArray.blitArray = function(surface, surfaceArray) {
        return surface.context.putImageData(surfaceArray.imageData, 0, 0);
      };

      /**
      * a new gamejs.Surface on every access, representing
      * the current state of the SurfaceArray.
      * @type {gamejs.Surface}
      */


      SurfaceArray.prototype.surface = null;

      /**
      * The SurfaceArray can be constructed with a surface whose values
      * are then used to initialize the pixel array.
      *
      * The surface passed as argument is not modified by the SurfaceArray.
      *
      * If an array is used to construct SurfaceArray, the array must describe
      * the dimensions of the SurfaceArray [width, height].
      *
      * @param {gamejs.Surface|Array} surfaceOrDimensions
      * @see http://dev.w3.org/html5/2dcontext/#pixel-manipulation
      */


      function SurfaceArray(surfaceOrDimensions) {
        if (surfaceOrDimensions instanceof Array) {
          size = surfaceOrDimensions;
          imageData = Display.getSurface().context.createImageData(size[0], size[1]);
          data = imageData.data;
        } else {
          size = surfaceOrDimensions.getSize();
          imageData = surfaceOrDimensions.getImageData(0, 0, size[0], size[1]);
          data = imageData.data;
        }
        Objects.accessors(this, {
          surface: {
            get: function() {
              var s;
              s = new Surface(size);
              s.context.putImageData(imageData, 0, 0);
              return s;
            }
          },
          imageData: {
            get: function() {
              return imageData;
            }
          }
        });
      }

      /*
           * Set rgba value at position x, y.
           *
           * For performance reasons this function has only one signature
           * being Number, Number, Array[4].
           *
           * @param {Number} x x position of pixel
           * @param {Number} y y position of pixel
           * @param {Array} rgba [red, green, blue, alpha] values [255, 255, 255, 255] (alpha, the last argument defaults to 255)
           * @throws Error if x, y out of range
      */


      SurfaceArray.prototype.set = function(x, y, rgba) {
        var offset;
        offset = (x * 4) + (y * size[0] * 4);
        /** faster without
        if (offset + 3 >= data.length || x < 0 || y < 0) {
           throw new Error('x, y out of range', x, y)
        }
        *
        */

        data[offset] = rgba[0];
        data[offset + 1] = rgba[1];
        data[offset + 2] = rgba[2];
        return data[offset + 3] = rgba[3] === void 0 ? 255 : rgba[3];
      };

      /**
      * Get rgba value at position xy,
      * @param {Number} x
      * @param {Number} y
      * @returns {Array} [red, green, blue, alpha]
      */


      SurfaceArray.prototype.get = function(x, y) {
        var offset;
        offset = (x * 4) + (y * size[0] * 4);
        return [data[offset], data[offset + 1], data[offset + 2], data[offset + 3]];
      };

      SurfaceArray.prototype.getSize = function() {
        return size;
      };

      return SurfaceArray;

    })();
  });

}).call(this);
